<template>
  <FieldWrapper :label="label" :error="error" :class-name="` ${className || ''} ${isOpen ? 'active' : ''}`">
    <div
      :ref="setRef"
      :class="[
        'autocomplete',
        {
          active: isOpen,
          disabled,
        },
      ]"
    >
      <div class="autocomplete__header" @click.stop="headerClickHandler">
        <div :class="['autocomplete__preview', { placeholder: !modelValue }]">
          <input
            v-model="searchQuery"
            type="text"
            class="autocomplete__input"
            :placeholder="placeholder"
            :disabled="disabled"
            @input="ajaxSearchHandler"
          />
        </div>
      </div>
      <div v-if="isOpen" class="autocomplete__option-list">
        <div class="autocomplete__option-wrapper">
          <div
            v-for="option in options"
            :key="(option.code as string)"
            class="autocomplete__option"
            tabindex="0"
            @click.stop.prevent="optionClickHandler(option)"
          >
            {{ option.label }}
          </div>
        </div>
      </div>
    </div>
  </FieldWrapper>
</template>

<script lang="ts" setup>
import FieldWrapper from '../FieldWrapper/FieldWrapper.vue';
import type { Option } from '../../../type/form/Option';
import { onMounted, onUnmounted, ref, watch } from 'vue';
import debounce from 'lodash-es/debounce';

interface Props {
  label?: string;
  error?: string;
  disabled?: boolean;
  className?: string;
  name: string;
  options: Option[];
  modelValue?: string;
  placeholder?: string;
}

const wrapperRef = ref<unknown>(null);
defineExpose({ wrapperRef });

const setRef = (val: unknown) => {
  wrapperRef.value = val;
};
const props = defineProps<Props>();
const emit = defineEmits(['update:modelValue', 'query']);
const isOpen = ref<boolean>(false);
const searchQuery = ref<string>('');
const cleanup = ref<(() => void) | null>(null);

const optionClickHandler = (event: Option) => {
  isOpen.value = false;
  emit('update:modelValue', event.code, props.name);
  searchQuery.value = '';
};

const headerClickHandler = () => {
  if (props.disabled) {
    return;
  }
  isOpen.value = !isOpen.value;
};

const documentClickHandler = () => {
  isOpen.value = false;
};

const ajaxSearchHandler = debounce(() => {
  if (searchQuery.value.length >= 3) {
    emit('query', searchQuery.value);
  } else if (!searchQuery.value.length) {
    emit('update:modelValue', '', props.name);
  }
}, 500);

watch(isOpen, (oldValue, clean) => {
  cleanup.value = clean as unknown as () => void;

  if (oldValue) {
    document.addEventListener('click', documentClickHandler);
  } else {
    document.removeEventListener('click', documentClickHandler);
  }
});

watch(
  () => props.modelValue,
  (newVal) => {
    searchQuery.value = newVal as string;
  }
);

onUnmounted(() => cleanup.value?.());

onMounted(() => {
  if (props.modelValue) {
    console.log(props, 'PROPSPROPS');
    searchQuery.value = props.modelValue;
  }
});
</script>

<style lang="scss">
@import './AutocompleteField';
</style>
